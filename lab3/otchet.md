# Лабораторная работа №3

## Задание 1

```
Написать функцию GetMinMax в find_max_min.c, которая ищет минимальный и максимальный элементы массива, на заданном промежутке.
Разобраться, что делает программа в sequiential_min_max.c, скомпилировать, проверить, что написанный вами GetMinMax работает правильно.
```

> Аргументы командной строки - параметры, которые передаеются программе при её запуске из терминала.
Сборка с помощью gcc - процесс превращения исходного кода (.c файлы) в исполняемую программу. gcc — это компилятор, который выполняет этот процесс в несколько этапов: препроцессинг, компиляция в ассемблер, ассемблирование в машинный код (создание объектных файлов .o) и, наконец, линковка (сборка всех .o файлов и библиотек в один исполняемый файл).

Дописали
```c
  for (unsigned i = begin; i < end; i++) {
    if (array[i] < min_max.min) {
      min_max.min = array[i];
    }
    if (array[i] > min_max.max) {
      min_max.max = array[i];
    }
  }
```
Скомпилировали
`make sequential_min_max`
Запустили
`./sequential_min_max 42 10000`
Вывод
```
min: 3889
max: 2147299420
```

## Задание 2 - 3

```
Завершить программу parallel_min_max.c, так, чтобы задача нахождения минимума и максимума в массиве решалась параллельно.
Если выставлен аргумент `by_files` для синхронизации процессов использовать файлы (задание 2), в противном случае использовать pipe (задание 3).
```

>1. Системный вызов fork()
Это основной способ создания новых процессов в Unix-подобных системах.
fork() создаёт точную копию текущего процесса. Процесс, который вызвал fork(), называется родительским, а новый процесс — дочерним.
После вызова fork() оба процесса продолжают выполнение с той же точки кода. Они имеют идентичные (но отдельные) копии памяти.
Как их различить? Ключевой момент — возвращаемое значение fork():
В родительском процессе fork() возвращает PID (идентификатор) нового дочернего процесса.
В дочернем процессе fork() возвращает 0.
Если процесс создать не удалось, возвращается -1.
>
>2. Системный вызов pipe()
Это механизм межпроцессного взаимодействия (IPC), который создаёт однонаправленный канал данных.
pipe() создаёт "трубу" и возвращает два файловых дескриптора (целых числа, являющихся идентификаторами потоков ввода-вывода):
`fd[0]` — для чтения из канала.
`fd[1]` — для записи в канал.
Один процесс использует дескриптор `fd[1]` для записи данных, а другой процесс использует `fd[0]` для их чтения. Данные работают по принципу FIFO (First-In, First-Out).
>
>3. Работа с файлами в Си
Это альтернативный, более медленный способ межпроцессного взаимодействия. Процесс обмена данными происходит через жёсткий диск.
Основной цикл работы:
`fopen("filename", "w")`: Открыть файл для записи. Возвращает указатель на структуру FILE.
`fprintf(file_pointer, ...)`: Записать форматированные данные в файл.
`fclose(file_pointer)`: Закрыть файл.
Другой процесс может открыть тот же файл для чтения с помощью `fopen()`, прочитать данные с помощью fscanf() и закрыть его.

Дописали
```c
...
          case 0:
            seed = atoi(optarg);
            if (seed <= 0) {
              printf("seed is a positive number\n");
              return 1;
            }
            break;
          case 1:
            array_size = atoi(optarg);
            if (array_size <= 0) {
              printf("array_size is a positive number\n");
              return 1;
            }
            break;
          case 2:
            pnum = atoi(optarg);
            if (pnum <= 0) {
              printf("pnum is a positive number\n");
              return 1;
            }
            break;
...
итд
...
```

## Задание 4

```
Изучить все targets в makefile, будьте готовы объяснить, за что они отвечают. Используя `makefile`, собрать получившиеся решения. Добавьте target `all`, отвечающий за сборку всех программ.
```

>**Makefile** — это файл-инструкция для утилиты make, которая автоматизирует сборку программ. Его основная идея — управление зависимостями.
Цель (Target): То, что мы хотим получить. Обычно это имя исполняемого или объектного файла.
Зависимости (Dependencies): Файлы, которые нужны для создания цели.
Команда (Command): Действие, которое нужно выполнить для создания цели из её зависимостей.
>
>make проверяет время последнего изменения зависимостей. Цель пересобирается только в том случае, если хотя бы одна из её зависимостей новее, чем сама цель. Это экономит массу времени, так как перекомпилируются только изменившиеся части проекта.

>У нас в Makefile:
`all : sequential_min_max parallel_min_max`: all — это псевдоцель (не является файлом). Она зависит от двух других целей. Когда пишем make all (или просто make), make пытается построить sequential_min_max и parallel_min_max.
`sequential_min_max : utils.o find_min_max.o ...`: Эта цель будет собрана с помощью gcc, только если utils.o, find_min_max.o или sequential_min_max.c изменились.

Добавили all:
```makefile
all: sequential_min_max parallel_min_max
```

Проверяем, собираем всё
`make`
Результат:
```bash
gcc -o utils.o -c utils.c -I.
gcc -o find_min_max.o -c find_min_max.c -I.
gcc -o sequential_min_max find_min_max.o utils.o sequential_min_max.c -I.
gcc -o parallel_min_max utils.o find_min_max.o parallel_min_max.c -I.
```

Проверяем скрипты:
`./parallel_min_max --seed 42 --array_size 10000 --pnum 4`
```
Min: 3889
Max: 2147299420
Elapsed time: 0.472000ms
```
`./parallel_min_max --seed 42 --array_size 10000 --pnum 4 --by_files`
```
Min: 3889
Max: 2147299420
Elapsed time: 32.452000ms
```

## Задание 5

```
Написать программу, которая запускает в отдельном процессе ваше приложение sequiential_min_max. Добавить его сборку в ваш makefile.
```

>Семейство функций `exec` (например, `execvp`, `execlp`) заменяет текущий процесс новым процессом.
`fork()` vs `exec()`:
`fork()` клонирует процесс. После `fork()` у нас два почти идентичных процесса.
`exec()` замещает процесс. Код, память, данные — всё стирается и заменяется новой программой. Если exec() успешен, он никогда не возвращает управление в исходную программу.
Классическая комбинация: `fork() + exec()` — это стандартный способ запуска новой программы в Unix.
Родительский процесс вызывает `fork()`, чтобы создать дочерний процесс.
Дочерний процесс вызывает `exec()`, чтобы загрузить новую программу.
Родительский процесс обычно вызывает `wait()`, чтобы дождаться завершения дочернего процесса.
>
>launcher.c использует fork(), а затем дочерний процесс вызывает execvp("./sequential_min_max", args), чтобы полностью заменить себя программой поиска минимума и максимума.

Создали laumcher.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == -1) {
        perror("fork failed");
        return 1;
    }

    if (pid == 0) {
        printf("Child process is starting sequential_min_max...\n");
        fflush(stdout);

        char *args[] = {"./sequential_min_max", "42", "10000", NULL};
        execvp(args[0], args);

        perror("execvp failed");
        exit(1);

    } else {
        printf("Parent process is waiting for the child to finish.\n");
        wait(NULL);
        printf("Child process finished.\n");
    }

    return 0;
}
```

Добавили в makefile
```makefile
launcher: launcher.c
	$(CC) -o launcher launcher.c $(CFLAGS)
```

Проверяем всё:
`make`
Результат:
```
gcc -o launcher launcher.c -I.
```
Выполняем:
`./launcher`
Результат:
```
Parent process is waiting for the child to finish.
Child process is starting sequential_min_max...
min: 3889
max: 2147299420
Child process finished.
```