# ЛР 2
## Задание 1

```
В папке swap лежит 3 файла: swap.c, swap.h и main.c. Ваша задача закончить метод Swap в swap.c, так, чтобы он менял местами два символа. Скомпилировать программу. Если вы все сделали верно, то программа, которую вы собрали выведет "b a".
```

>Чтобы функция могла изменить исходную переменную, необходимо передать в неё указатель на неё. Внутри функции, используя операцию разыменования, можно получить доступ к значению по этому адресу и изменить его.

Дописали `swap.c`
```c
#include "swap.h"

void Swap(char *left, char *right)
{
    char temp = *left;
    *left = *right;
    *right = temp;
}
```

Скомпилировали `gcc main.c swap.c -o swap_app`
Заупстили `./swap_app`
Получили
```
b a
```

## Задание 2

```
В папке revert_string содержатся файлы main.c, revert_string.h, revert_string.c. Вам необходимо реализовать метод RevertString в revert_string.c, который должен переворачивать данную пользователем строку.
Изучить код main.c, скомпилировать программу, рассказать, как она работает и, что делает.
```

>Для динам. выделения памяти в куче используется функция malloc(). Она принимает количество байт, которое нужно выделить, и возвращает указатель на начало выделенного блока памяти.
Память нужно освобождать вручную с помощью функции free(), передав ей указатель, который вернул malloc().

| Характеристика | Стек (Stack) | Куча (Heap) |
| -------------- | ------------ | ----------- |
| Управление памятью | Автоматическое | Ручное |
| Скорость доступа | Очень высокая. Структура данных LIFO (Last-In, First-Out).	| Медленнее, чем в стеке, так как поиск свободного блока может занять время. |
| Размер | Ограничен и относительно мал. | Ограничен только объемом доступной оперативной памяти. |
| Время жизни данных | Локальные переменные живут только во время выполнения функции. | Данные живут до тех пор, пока не будут освобождены. |
| Использование | Локальные переменные, параметры функций. | Данные, размер которых неизвестен на этапе компиляции, или данные, которые должны существовать дольше, чем одна функция. |


>Си может принимать аргументы при запуске из терминала. За это отвечают два параметра функции main:
> * int argc (c - count): Целое число, содержащее количество переданных аргументов (название программы всегда считается первым аргументом)
> * char *argv[] (v - vector): Массив строк, где каждый элемент — это один из аргументов



Дописали `revert_string.c`
```c
#include "revert_string.h"
#include <string.h>

void RevertString(char *str)
{
    int i = 0;
    int j = strlen(str) - 1;
    char temp;

    while (i < j) {
        temp = str[i];
        str[i] = str[j];
        str[j] = temp;
        i++;
        j--;
    }
}
```

Скомпилировали `gcc main.c revert_string.c -o revert_app`
Заупстили `./revert_app "Hello World!"`
Получили
```
Reverted: !dlroW olleH
```

## Задание 3

```
В задании 2, вы написали маленькую библиотеку с одной функцией, переворота строки. Тем не менее этот код уже можно переиспользовать, а чтобы это было удобнее делать, его необходимо вынести в библиотеку. Ваше задание скомпилировать статическую и динамическую библиотеки с RevertString и залинковать их в приложения с main.c.
```

>1. Основы работы компилятора: препроцессор, компилятор, линковщик
**Препроцессинг**: Препроцессор обрабатывает директивы, начинающиеся с # (#include, #define и т.д.). Он вставляет содержимое заголовочных файлов, заменяет макросы и удаляет комментарии.
**Компиляция**: Компилятор переводит обработанный препроцессором код на язык ассемблера — низкоуровневый, но все еще понятный человеку язык инструкций.
**Ассемблирование**: Ассемблер преобразует код на языке ассемблера в машинный код (нули и единицы) и создает объектный файл (с расширением .o). Этот файл уже содержит инструкции для процессора, но еще не является готовой программой.
**Линковка (компоновка)**: Линковщик (компоновщик) собирает один или несколько объектных файлов и связывает их с необходимыми библиотечными функциями (например, printf из стандартной библиотеки), чтобы создать единый исполняемый файл.
>
>2. Что такое статическая и динамическая линковка?
**Статическая линковка**: Код библиотечных функций, которые использует программа, полностью копируется в исполняемый файл на этапе линковки.
*Плюсы*: Программа становится автономной и не зависит от наличия библиотек в системе.
*Минусы*: Размер исполняемого файла увеличивается. Если в библиотеке найдется ошибка, придется перекомпилировать все программы, которые её используют.
**Динамическая линковка**: В исполняемый файл добавляются не сами функции, а только ссылки (указания) на них. Код библиотек подгружается в память операционной системой уже во время запуска программы.
*Плюсы*: Экономия места на диске и в оперативной памяти (одна копия библиотеки используется всеми программами). Библиотеку можно обновить без перекомпиляции программ.
*Минусы*: Программа зависит от наличия в системе нужной версии библиотеки.
>
>3. Опции компилятора GCC
-I<путь> (Include): Указывает компилятору, в какой дополнительной директории искать заголовочные файлы (.h).
-L<путь> (Library): Указывает линковщику, где искать файлы библиотек (.a, .so).
-l<имя> (link): Говорит линковщику подключить библиотеку с указанным именем (например, -lcunit ищет файл libcunit.so или libcunit.a).
-shared: Указывает компилятору создать динамическую (разделяемую) библиотеку.
-o <имя_файла> (output): Задает имя для выходного файла (исполняемого, объектного или библиотеки).
-c (compile): Скомпилировать исходный код в объектный файл (.o), но не выполнять линковку.
-fPIC (Position-Independent Code): Создает позиционно-независимый код, который необходим для динамических библиотек, так как они могут быть загружены в любой свободный участок памяти.
>
>4. Утилита ar и переменная LD_LIBRARY_PATH
**ar**: Это утилита-архиватор. В контексте Си она используется для объединения одного или нескольких объектных файлов (.o) в единый файл статической библиотеки (.a).
**LD_LIBRARY_PATH**: Это переменная окружения в Linux, которая содержит список директорий, где система будет искать динамические библиотеки (.so) во время запуска программ.


### Статическая
Компилируем revert_string.c в объектный файл (.o)
`gcc -c revert_string.c -o revert_string.o`
Создаем статическую библиотеку libRevertString.a из объектного файла
`ar rcs libRevertString.a revert_string.o`
Компилируем main.c и линкуем его с нашей статической библиотекой
    -L. искать в текущей директории
   -lRevertString имя библиотеки (lib и .a автоматически)
`gcc main.c -L. -lRevertString -o static_revert_app`
Запускаем
`./static_revert_app "Static Test"`
Получили:
```
Reverted: tseT citatS
```

### Динамическая

Компилируем revert_string.c в объектный файл с позиционно-независимым кодом
`gcc -fPIC -c revert_string.c -o revert_string.o`
Создаем динамическую библиотеку
`gcc -shared revert_string.o -o libRevertString.so`
Компилируем main.c и линкуем его с динамической библиотекой
`gcc main.c -L. -lRevertString -o dynamic_revert_app`
Указываем системе, где искать библиотеку
`export LD_LIBRARY_PATH=.`
Запускаем
`./dynamic_revert_app "Dynamic Test"`

Получили:
```
Reverted: tseT cimanyD
```

## Задание 4

```
Если вы зайдете в update.sh, то увидите, слежующую строчку `sudo apt -y install libcunit1 libcunit1-doc libcunit1-dev`. Это установка в вашу систему библиотеки для юнит тестирования на языке Си - CUnit. В папочке test вы найдете tests.c - готовую программу, которая запускает несколько юнит тестов для функции RevertString. Ваша задача, скомпилировать эту программу с динамической библиотекой из **Задания 3**. Важно, что программа с тестами и программа из **Задания 2** должны использовать одну библиотеку (один файл). 
```

Копируем динамическую библиотеку
`cp ../revert_string/libRevertString.so .`

Компилируем тесты, указывая, где искать заголовочные файлы (-I..)
и линкуясь с нашей динамической библиотекой (-L. -lRevertString)
и библиотекой CUnit (-lcunit)
`gcc tests.c -o tests_app -I../revert_string -L. -lRevertString -lcunit`

Указываем путь к нашей библиотеке и запускаем тесты
`LD_LIBRARY_PATH=. ./tests_app`

Получили:
```


     CUnit - A unit testing framework for C - Version 2.1-3
     http://cunit.sourceforge.net/


Suite: Suite
  Test: test of RevertString function ...passed

Run Summary:    Type  Total    Ran Passed Failed Inactive
              suites      1      1    n/a      0        0
               tests      1      1      1      0        0
             asserts      4      4      4      0      n/a

Elapsed time =    0.000 seconds
```
Значит всё ок